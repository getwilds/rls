---
title: "Getting Started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



Row Level Security for PostgreSQL and AWS Redshift.

The following is a walk-through of using row level security in PostgreSQL, including checks to make sure policies behave as expected.


``` r
library(tibble)
library(DBI)
library(RPostgres)
library(dplyr)
#> 
#> Attaching package: 'dplyr'
#> The following objects are masked from 'package:stats':
#> 
#>     filter, lag
#> The following objects are masked from 'package:base':
#> 
#>     intersect, setdiff, setequal, union
library(dbplyr)
#> 
#> Attaching package: 'dbplyr'
#> The following objects are masked from 'package:dplyr':
#> 
#>     ident, sql
library(rls)
```

## Start PostgreSQL locally

Start Postgres however you do that.

## Create a connection


``` r
con <- dbConnect(Postgres())
```



## Create a table

Create the table (with no data)


``` r
invisible(dbExecute(con, "
  CREATE TABLE passwd (
  user_name             text UNIQUE NOT NULL,
  pwhash                text,
  uid                   int  PRIMARY KEY,
  gid                   int  NOT NULL,
  real_name             text NOT NULL,
  home_phone            text,
  home_dir              text NOT NULL,
  shell                 text NOT NULL
);
"))
#> Error: Failed to fetch row : ERROR:  relation "passwd" already exists
```

Some sample data


``` r
sample_data <- tribble(
  ~user_name, ~pwhash, ~uid, ~gid, ~real_name, ~home_phone, ~home_dir, ~shell,
  'admin','xxx',0,0,'Admin','111-222-3333','/root','/bin/dash',
  'bob','xxx',1,1,'Bob','123-456-7890','/home/bob','/bin/zsh',
  'alice','xxx',2,1,'Alice','098-765-4321','/home/alice','/bin/zsh'
)
```

Append rows to the `passwd` table


``` r
rows_append(
  tbl(con, "passwd"),
  copy_inline(con, sample_data),
  in_place = TRUE
)
#> Error in `rows_append()`:
#> ! Can't modify database table "passwd".
#> ℹ Using SQL: INSERT INTO "passwd" ("user_name", "pwhash", "uid", "gid", "real_name", "home_phone", "home_dir", "shell") SELECT * FROM (
#>   SELECT CAST("user_name" AS TEXT) AS "user_name", CAST("pwhash" AS TEXT) AS "pwhash", CAST("uid" AS NUMERIC) AS "uid", CAST("gid" AS
#>   NUMERIC) AS "gid", CAST("real_name" AS TEXT) AS "real_name", CAST("home_phone" AS TEXT) AS "home_phone", CAST("home_dir" AS TEXT) AS
#>   "home_dir", CAST("shell" AS TEXT) AS "shell" FROM ( VALUES ('admin', 'xxx', 0.0, 0.0, 'Admin', '111-222-3333', '/root', '/bin/dash'),
#>   ('bob', 'xxx', 1.0, 1.0, 'Bob', '123-456-7890', '/home/bob', '/bin/zsh'), ('alice', 'xxx', 2.0, 1.0, 'Alice', '098-765-4321',
#>   '/home/alice', '/bin/zsh') ) AS drvd("user_name", "pwhash", "uid", "gid", "real_name", "home_phone", "home_dir", "shell") ) AS "...y"
#> Caused by error:
#> ! Failed to fetch row : ERROR:  duplicate key value violates unique constraint "passwd_pkey"
#> DETAIL:  Key (uid)=(0) already exists.
```

Check that the data is in the table


``` r
tbl(con, "passwd")
#> # Source:   table<"passwd"> [3 x 8]
#> # Database: postgres  [schambe3@/tmp:5432/schambe3]
#>   user_name pwhash   uid   gid real_name   home_phone   home_dir    shell    
#>   <chr>     <chr>  <int> <int> <chr>       <chr>        <chr>       <chr>    
#> 1 bob       xxx        1     1 Bob         123-456-7890 /home/bob   /bin/zsh 
#> 2 alice     xxx        2     1 Alice       098-765-4321 /home/alice /bin/zsh 
#> 3 admin     xxx        0     0 Pink Dragon 111-222-3333 /root       /bin/dash
```

## Create roles


``` r
# Administrator
dbExecute(con, "CREATE ROLE admin")
#> Error: Failed to fetch row : ERROR:  role "admin" already exists
# Normal user
dbExecute(con, "CREATE ROLE bob")
#> Error: Failed to fetch row : ERROR:  role "bob" already exists
# Another normal user
dbExecute(con, "CREATE ROLE alice")
#> Error: Failed to fetch row : ERROR:  role "alice" already exists
```

## Enable row level security

Enable row level security with `rls_enable`


``` r
rls_enable(con, "passwd")
```

Then check that it worked with `rls_check_status`


``` r
rls_check_status(con, "passwd")
#> # A tibble: 1 × 3
#>   relname relrowsecurity relforcerowsecurity
#>   <chr>   <lgl>          <lgl>              
#> 1 passwd  TRUE           FALSE
```

## Create row level security policies

`admin_all` = Administrator can see all rows and add any rows


``` r
(policy1 <- rls_construct_policy(
  name = "admin_all",
  on = "passwd",
  to = "admin",
  using = "(true)",
  with = "(true)"
))
#> <rls_policy>
#>   policy name: admin_all
#>   on: passwd
#>   to: admin
#>   using: (true)
#>   with: (true)
rls_create_policy(con, policy1)
#> Error: Failed to fetch row : ERROR:  policy "admin_all" for table "passwd" already exists
rls_policies(con)
#> # A tibble: 3 × 8
#>   schemaname tablename policyname permissive roles      cmd    qual   with_check
#>   <chr>      <chr>     <chr>      <chr>      <pq__name> <chr>  <chr>  <chr>     
#> 1 public     passwd    admin_all  PERMISSIVE {admin}    ALL    true   true      
#> 2 public     passwd    all_view   PERMISSIVE {public}   SELECT true   <NA>      
#> 3 public     passwd    user_mod   PERMISSIVE {public}   UPDATE (CURR… ((CURRENT…
```

`all_view` = Normal users can view all rows


``` r
(policy2 <- rls_construct_policy(
  name = "all_view",
  on = "passwd",
  for_ = "SELECT",
  using = "(true)"
))
#> <rls_policy>
#>   policy name: all_view
#>   on: passwd
#>   for: SELECT
#>   using: (true)
rls_create_policy(con, policy2)
#> Error: Failed to fetch row : ERROR:  policy "all_view" for table "passwd" already exists
rls_policies(con)
#> # A tibble: 3 × 8
#>   schemaname tablename policyname permissive roles      cmd    qual   with_check
#>   <chr>      <chr>     <chr>      <chr>      <pq__name> <chr>  <chr>  <chr>     
#> 1 public     passwd    admin_all  PERMISSIVE {admin}    ALL    true   true      
#> 2 public     passwd    all_view   PERMISSIVE {public}   SELECT true   <NA>      
#> 3 public     passwd    user_mod   PERMISSIVE {public}   UPDATE (CURR… ((CURRENT…
```

`user_mod` = Normal users can update their own records, but limit
which shells a normal user is allowed to set


``` r
(policy3 <- rls_construct_policy(
  name = "user_mod",
  on = "passwd",
  for_ = "UPDATE",
  using = "(current_user = user_name)",
  with = "(
    current_user = user_name AND
    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
  )"
))
#> <rls_policy>
#>   policy name: user_mod
#>   on: passwd
#>   for: UPDATE
#>   using: (current_user = user_name)
#>   with: (
#>     current_user = user_name AND
#>     shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')
#>   )
rls_create_policy(con, policy3)
#> Error: Failed to fetch row : ERROR:  policy "user_mod" for table "passwd" already exists
rls_policies(con)
#> # A tibble: 3 × 8
#>   schemaname tablename policyname permissive roles      cmd    qual   with_check
#>   <chr>      <chr>     <chr>      <chr>      <pq__name> <chr>  <chr>  <chr>     
#> 1 public     passwd    admin_all  PERMISSIVE {admin}    ALL    true   true      
#> 2 public     passwd    all_view   PERMISSIVE {public}   SELECT true   <NA>      
#> 3 public     passwd    user_mod   PERMISSIVE {public}   UPDATE (CURR… ((CURRENT…
```

## Grant permissions

Allow admin all normal rights


``` r
dbExecute(con, "GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin")
```

Users only get select access on public columns


``` r
dbExecute(con, "GRANT SELECT
  (user_name, uid, gid, real_name, home_phone, home_dir, shell)
  ON passwd TO public"
)
```

Allow users to update certain columns


``` r
dbExecute(con, "GRANT UPDATE
  (pwhash, real_name, home_phone, shell)
  ON passwd TO public"
)
```

## Ensure the system behaves as expected

Admin can access all columns


``` r
dbExecute(con, "SET SESSION AUTHORIZATION admin")
#> [1] 0
tbl(con, "passwd")
#> # Source:   table<"passwd"> [3 x 8]
#> # Database: postgres  [schambe3@/tmp:5432/schambe3]
#>   user_name pwhash   uid   gid real_name   home_phone   home_dir    shell    
#>   <chr>     <chr>  <int> <int> <chr>       <chr>        <chr>       <chr>    
#> 1 bob       xxx        1     1 Bob         123-456-7890 /home/bob   /bin/zsh 
#> 2 alice     xxx        2     1 Alice       098-765-4321 /home/alice /bin/zsh 
#> 3 admin     xxx        0     0 Pink Dragon 111-222-3333 /root       /bin/dash
```

Alice can NOT access all columns


``` r
dbExecute(con, "SET SESSION AUTHORIZATION alice")
#> [1] 0
tbl(con, "passwd") # "passwd" here means "SELECT * from passwd"
#> Error in `db_query_fields.DBIConnection()`:
#> ! Can't query fields.
#> ℹ Using SQL: SELECT * FROM "passwd" AS "q01" WHERE (0 = 1)
#> Caused by error:
#> ! Failed to fetch row : ERROR:  permission denied for table passwd
```

Alice can access all columns except for `pwhash`


``` r
sql1 <- sql("SELECT user_name,real_name,home_phone,home_dir,shell FROM passwd")
tbl(con, sql1)
#> # Source:   SQL [3 x 5]
#> # Database: postgres  [schambe3@/tmp:5432/schambe3]
#>   user_name real_name   home_phone   home_dir    shell    
#>   <chr>     <chr>       <chr>        <chr>       <chr>    
#> 1 bob       Bob         123-456-7890 /home/bob   /bin/zsh 
#> 2 alice     Alice       098-765-4321 /home/alice /bin/zsh 
#> 3 admin     Pink Dragon 111-222-3333 /root       /bin/dash
```

Alice can not do UPDATE operations on certain columns
(in this case `user_name`)


``` r
dbExecute(con, "UPDATE passwd SET user_name = 'joe'")
#> Error: Failed to fetch row : ERROR:  permission denied for table passwd
```

Alice can however update `real_name`


``` r
dbExecute(con, "UPDATE passwd SET real_name = 'Alice Doe'")
#> [1] 1
```

She can update `real_name`, but the update doesn't alter any rows
when it has a WHERE clause on `user_name`


``` r
dbExecute(con, "UPDATE passwd SET real_name = 'John Doe' WHERE user_name = 'admin'")
#> [1] 0
```

Alice can not update the `shell` column to an invalid value as
defined by our row-level security policy above


``` r
dbExecute(con, "UPDATE passwd SET shell = '/bin/xx'")
#> Error: Failed to fetch row : ERROR:  new row violates row-level security policy for table "passwd"
```

Alice can not delete the `passwd` table and can not do any insert
operations


``` r
dbExecute(con, "DELETE from passwd")
#> Error: Failed to fetch row : ERROR:  permission denied for table passwd
dbExecute(con, "INSERT INTO passwd (user_name) VALUES ('xxx')")
#> Error: Failed to fetch row : ERROR:  permission denied for table passwd
```

Alice can change her own password; RLS silently prevents updating
other rows


``` r
dbExecute(con, "UPDATE passwd SET pwhash = 'abc'")
#> [1] 1
```



